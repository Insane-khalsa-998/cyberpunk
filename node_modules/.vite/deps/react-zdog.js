import {
  require_react
} from "./chunk-UGC3UZ7L.js";
import {
  __commonJS,
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/zdog/js/boilerplate.js
var require_boilerplate = __commonJS({
  "node_modules/zdog/js/boilerplate.js"(exports, module) {
    (function(root, factory) {
      if (typeof module == "object" && module.exports) {
        module.exports = factory();
      } else {
        root.Zdog = factory();
      }
    })(exports, function factory() {
      var Zdog = {};
      Zdog.TAU = Math.PI * 2;
      Zdog.extend = function(a, b) {
        for (var prop in b) {
          a[prop] = b[prop];
        }
        return a;
      };
      Zdog.lerp = function(a, b, alpha) {
        return (b - a) * alpha + a;
      };
      Zdog.modulo = function(num, div) {
        return (num % div + div) % div;
      };
      var powerMultipliers = {
        2: function(a) {
          return a * a;
        },
        3: function(a) {
          return a * a * a;
        },
        4: function(a) {
          return a * a * a * a;
        },
        5: function(a) {
          return a * a * a * a * a;
        }
      };
      Zdog.easeInOut = function(alpha, power) {
        if (power == 1) {
          return alpha;
        }
        alpha = Math.max(0, Math.min(1, alpha));
        var isFirstHalf = alpha < 0.5;
        var slope = isFirstHalf ? alpha : 1 - alpha;
        slope /= 0.5;
        var powerMultiplier = powerMultipliers[power] || powerMultipliers[2];
        var curve = powerMultiplier(slope);
        curve /= 2;
        return isFirstHalf ? curve : 1 - curve;
      };
      return Zdog;
    });
  }
});

// node_modules/zdog/js/canvas-renderer.js
var require_canvas_renderer = __commonJS({
  "node_modules/zdog/js/canvas-renderer.js"(exports, module) {
    (function(root, factory) {
      if (typeof module == "object" && module.exports) {
        module.exports = factory();
      } else {
        root.Zdog.CanvasRenderer = factory();
      }
    })(exports, function factory() {
      var CanvasRenderer = { isCanvas: true };
      CanvasRenderer.begin = function(ctx) {
        ctx.beginPath();
      };
      CanvasRenderer.move = function(ctx, elem, point) {
        ctx.moveTo(point.x, point.y);
      };
      CanvasRenderer.line = function(ctx, elem, point) {
        ctx.lineTo(point.x, point.y);
      };
      CanvasRenderer.bezier = function(ctx, elem, cp0, cp1, end) {
        ctx.bezierCurveTo(cp0.x, cp0.y, cp1.x, cp1.y, end.x, end.y);
      };
      CanvasRenderer.closePath = function(ctx) {
        ctx.closePath();
      };
      CanvasRenderer.setPath = function() {
      };
      CanvasRenderer.renderPath = function(ctx, elem, pathCommands, isClosed) {
        this.begin(ctx, elem);
        pathCommands.forEach(function(command) {
          command.render(ctx, elem, CanvasRenderer);
        });
        if (isClosed) {
          this.closePath(ctx, elem);
        }
      };
      CanvasRenderer.stroke = function(ctx, elem, isStroke, color, lineWidth) {
        if (!isStroke) {
          return;
        }
        ctx.strokeStyle = color;
        ctx.lineWidth = lineWidth;
        ctx.stroke();
      };
      CanvasRenderer.fill = function(ctx, elem, isFill, color) {
        if (!isFill) {
          return;
        }
        ctx.fillStyle = color;
        ctx.fill();
      };
      CanvasRenderer.end = function() {
      };
      return CanvasRenderer;
    });
  }
});

// node_modules/zdog/js/svg-renderer.js
var require_svg_renderer = __commonJS({
  "node_modules/zdog/js/svg-renderer.js"(exports, module) {
    (function(root, factory) {
      if (typeof module == "object" && module.exports) {
        module.exports = factory();
      } else {
        root.Zdog.SvgRenderer = factory();
      }
    })(exports, function factory() {
      var SvgRenderer = { isSvg: true };
      var round = SvgRenderer.round = function(num) {
        return Math.round(num * 1e3) / 1e3;
      };
      function getPointString(point) {
        return round(point.x) + "," + round(point.y) + " ";
      }
      SvgRenderer.begin = function() {
      };
      SvgRenderer.move = function(svg, elem, point) {
        return "M" + getPointString(point);
      };
      SvgRenderer.line = function(svg, elem, point) {
        return "L" + getPointString(point);
      };
      SvgRenderer.bezier = function(svg, elem, cp0, cp1, end) {
        return "C" + getPointString(cp0) + getPointString(cp1) + getPointString(end);
      };
      SvgRenderer.closePath = function() {
        return "Z";
      };
      SvgRenderer.setPath = function(svg, elem, pathValue) {
        elem.setAttribute("d", pathValue);
      };
      SvgRenderer.renderPath = function(svg, elem, pathCommands, isClosed) {
        var pathValue = "";
        pathCommands.forEach(function(command) {
          pathValue += command.render(svg, elem, SvgRenderer);
        });
        if (isClosed) {
          pathValue += this.closePath(svg, elem);
        }
        this.setPath(svg, elem, pathValue);
      };
      SvgRenderer.stroke = function(svg, elem, isStroke, color, lineWidth) {
        if (!isStroke) {
          return;
        }
        elem.setAttribute("stroke", color);
        elem.setAttribute("stroke-width", lineWidth);
      };
      SvgRenderer.fill = function(svg, elem, isFill, color) {
        var fillColor = isFill ? color : "none";
        elem.setAttribute("fill", fillColor);
      };
      SvgRenderer.end = function(svg, elem) {
        svg.appendChild(elem);
      };
      return SvgRenderer;
    });
  }
});

// node_modules/zdog/js/vector.js
var require_vector = __commonJS({
  "node_modules/zdog/js/vector.js"(exports, module) {
    (function(root, factory) {
      if (typeof module == "object" && module.exports) {
        module.exports = factory(require_boilerplate());
      } else {
        var Zdog = root.Zdog;
        Zdog.Vector = factory(Zdog);
      }
    })(exports, function factory(utils) {
      function Vector(position) {
        this.set(position);
      }
      var TAU = utils.TAU;
      Vector.prototype.set = function(pos) {
        this.x = pos && pos.x || 0;
        this.y = pos && pos.y || 0;
        this.z = pos && pos.z || 0;
        return this;
      };
      Vector.prototype.write = function(pos) {
        if (!pos) {
          return this;
        }
        this.x = pos.x != void 0 ? pos.x : this.x;
        this.y = pos.y != void 0 ? pos.y : this.y;
        this.z = pos.z != void 0 ? pos.z : this.z;
        return this;
      };
      Vector.prototype.rotate = function(rotation) {
        if (!rotation) {
          return;
        }
        this.rotateZ(rotation.z);
        this.rotateY(rotation.y);
        this.rotateX(rotation.x);
        return this;
      };
      Vector.prototype.rotateZ = function(angle) {
        rotateProperty(this, angle, "x", "y");
      };
      Vector.prototype.rotateX = function(angle) {
        rotateProperty(this, angle, "y", "z");
      };
      Vector.prototype.rotateY = function(angle) {
        rotateProperty(this, angle, "x", "z");
      };
      function rotateProperty(vec, angle, propA, propB) {
        if (!angle || angle % TAU === 0) {
          return;
        }
        var cos = Math.cos(angle);
        var sin = Math.sin(angle);
        var a = vec[propA];
        var b = vec[propB];
        vec[propA] = a * cos - b * sin;
        vec[propB] = b * cos + a * sin;
      }
      Vector.prototype.isSame = function(pos) {
        if (!pos) {
          return false;
        }
        return this.x === pos.x && this.y === pos.y && this.z === pos.z;
      };
      Vector.prototype.add = function(pos) {
        if (!pos) {
          return this;
        }
        this.x += pos.x || 0;
        this.y += pos.y || 0;
        this.z += pos.z || 0;
        return this;
      };
      Vector.prototype.subtract = function(pos) {
        if (!pos) {
          return this;
        }
        this.x -= pos.x || 0;
        this.y -= pos.y || 0;
        this.z -= pos.z || 0;
        return this;
      };
      Vector.prototype.multiply = function(pos) {
        if (pos == void 0) {
          return this;
        }
        if (typeof pos == "number") {
          this.x *= pos;
          this.y *= pos;
          this.z *= pos;
        } else {
          this.x *= pos.x != void 0 ? pos.x : 1;
          this.y *= pos.y != void 0 ? pos.y : 1;
          this.z *= pos.z != void 0 ? pos.z : 1;
        }
        return this;
      };
      Vector.prototype.transform = function(translation, rotation, scale) {
        this.multiply(scale);
        this.rotate(rotation);
        this.add(translation);
        return this;
      };
      Vector.prototype.lerp = function(pos, alpha) {
        this.x = utils.lerp(this.x, pos.x || 0, alpha);
        this.y = utils.lerp(this.y, pos.y || 0, alpha);
        this.z = utils.lerp(this.z, pos.z || 0, alpha);
        return this;
      };
      Vector.prototype.magnitude = function() {
        var sum = this.x * this.x + this.y * this.y + this.z * this.z;
        return getMagnitudeSqrt(sum);
      };
      function getMagnitudeSqrt(sum) {
        if (Math.abs(sum - 1) < 1e-8) {
          return 1;
        }
        return Math.sqrt(sum);
      }
      Vector.prototype.magnitude2d = function() {
        var sum = this.x * this.x + this.y * this.y;
        return getMagnitudeSqrt(sum);
      };
      Vector.prototype.copy = function() {
        return new Vector(this);
      };
      return Vector;
    });
  }
});

// node_modules/zdog/js/anchor.js
var require_anchor = __commonJS({
  "node_modules/zdog/js/anchor.js"(exports, module) {
    (function(root, factory) {
      if (typeof module == "object" && module.exports) {
        module.exports = factory(
          require_boilerplate(),
          require_vector(),
          require_canvas_renderer(),
          require_svg_renderer()
        );
      } else {
        var Zdog = root.Zdog;
        Zdog.Anchor = factory(
          Zdog,
          Zdog.Vector,
          Zdog.CanvasRenderer,
          Zdog.SvgRenderer
        );
      }
    })(exports, function factory(utils, Vector, CanvasRenderer, SvgRenderer) {
      var TAU = utils.TAU;
      var onePoint = { x: 1, y: 1, z: 1 };
      function Anchor(options) {
        this.create(options || {});
      }
      Anchor.prototype.create = function(options) {
        this.children = [];
        utils.extend(this, this.constructor.defaults);
        this.setOptions(options);
        this.translate = new Vector(options.translate);
        this.rotate = new Vector(options.rotate);
        this.scale = new Vector(onePoint).multiply(this.scale);
        this.origin = new Vector();
        this.renderOrigin = new Vector();
        if (this.addTo) {
          this.addTo.addChild(this);
        }
      };
      Anchor.defaults = {};
      Anchor.optionKeys = Object.keys(Anchor.defaults).concat([
        "rotate",
        "translate",
        "scale",
        "addTo"
      ]);
      Anchor.prototype.setOptions = function(options) {
        var optionKeys = this.constructor.optionKeys;
        for (var key in options) {
          if (optionKeys.indexOf(key) != -1) {
            this[key] = options[key];
          }
        }
      };
      Anchor.prototype.addChild = function(shape) {
        if (this.children.indexOf(shape) != -1) {
          return;
        }
        shape.remove();
        shape.addTo = this;
        this.children.push(shape);
      };
      Anchor.prototype.removeChild = function(shape) {
        var index = this.children.indexOf(shape);
        if (index != -1) {
          this.children.splice(index, 1);
        }
      };
      Anchor.prototype.remove = function() {
        if (this.addTo) {
          this.addTo.removeChild(this);
        }
      };
      Anchor.prototype.update = function() {
        this.reset();
        this.children.forEach(function(child) {
          child.update();
        });
        this.transform(this.translate, this.rotate, this.scale);
      };
      Anchor.prototype.reset = function() {
        this.renderOrigin.set(this.origin);
      };
      Anchor.prototype.transform = function(translation, rotation, scale) {
        this.renderOrigin.transform(translation, rotation, scale);
        this.children.forEach(function(child) {
          child.transform(translation, rotation, scale);
        });
      };
      Anchor.prototype.updateGraph = function() {
        this.update();
        this.updateFlatGraph();
        this.flatGraph.forEach(function(item) {
          item.updateSortValue();
        });
        this.flatGraph.sort(Anchor.shapeSorter);
      };
      Anchor.shapeSorter = function(a, b) {
        return a.sortValue - b.sortValue;
      };
      Object.defineProperty(Anchor.prototype, "flatGraph", {
        get: function() {
          if (!this._flatGraph) {
            this.updateFlatGraph();
          }
          return this._flatGraph;
        },
        set: function(graph) {
          this._flatGraph = graph;
        }
      });
      Anchor.prototype.updateFlatGraph = function() {
        this.flatGraph = this.getFlatGraph();
      };
      Anchor.prototype.getFlatGraph = function() {
        var flatGraph = [this];
        return this.addChildFlatGraph(flatGraph);
      };
      Anchor.prototype.addChildFlatGraph = function(flatGraph) {
        this.children.forEach(function(child) {
          var childFlatGraph = child.getFlatGraph();
          Array.prototype.push.apply(flatGraph, childFlatGraph);
        });
        return flatGraph;
      };
      Anchor.prototype.updateSortValue = function() {
        this.sortValue = this.renderOrigin.z;
      };
      Anchor.prototype.render = function() {
      };
      Anchor.prototype.renderGraphCanvas = function(ctx) {
        if (!ctx) {
          throw new Error("ctx is " + ctx + ". Canvas context required for render. Check .renderGraphCanvas( ctx ).");
        }
        this.flatGraph.forEach(function(item) {
          item.render(ctx, CanvasRenderer);
        });
      };
      Anchor.prototype.renderGraphSvg = function(svg) {
        if (!svg) {
          throw new Error("svg is " + svg + ". SVG required for render. Check .renderGraphSvg( svg ).");
        }
        this.flatGraph.forEach(function(item) {
          item.render(svg, SvgRenderer);
        });
      };
      Anchor.prototype.copy = function(options) {
        var itemOptions = {};
        var optionKeys = this.constructor.optionKeys;
        optionKeys.forEach(function(key) {
          itemOptions[key] = this[key];
        }, this);
        utils.extend(itemOptions, options);
        var ItemClass = this.constructor;
        return new ItemClass(itemOptions);
      };
      Anchor.prototype.copyGraph = function(options) {
        var clone = this.copy(options);
        this.children.forEach(function(child) {
          child.copyGraph({
            addTo: clone
          });
        });
        return clone;
      };
      Anchor.prototype.normalizeRotate = function() {
        this.rotate.x = utils.modulo(this.rotate.x, TAU);
        this.rotate.y = utils.modulo(this.rotate.y, TAU);
        this.rotate.z = utils.modulo(this.rotate.z, TAU);
      };
      function getSubclass(Super) {
        return function(defaults) {
          function Item(options) {
            this.create(options || {});
          }
          Item.prototype = Object.create(Super.prototype);
          Item.prototype.constructor = Item;
          Item.defaults = utils.extend({}, Super.defaults);
          utils.extend(Item.defaults, defaults);
          Item.optionKeys = Super.optionKeys.slice(0);
          Object.keys(Item.defaults).forEach(function(key) {
            if (!Item.optionKeys.indexOf(key) != 1) {
              Item.optionKeys.push(key);
            }
          });
          Item.subclass = getSubclass(Item);
          return Item;
        };
      }
      Anchor.subclass = getSubclass(Anchor);
      return Anchor;
    });
  }
});

// node_modules/zdog/js/dragger.js
var require_dragger = __commonJS({
  "node_modules/zdog/js/dragger.js"(exports, module) {
    (function(root, factory) {
      if (typeof module == "object" && module.exports) {
        module.exports = factory();
      } else {
        root.Zdog.Dragger = factory();
      }
    })(exports, function factory() {
      var hasWindow = typeof window != "undefined";
      var downEvent = "mousedown";
      var moveEvent = "mousemove";
      var upEvent = "mouseup";
      if (hasWindow) {
        if (window.PointerEvent) {
          downEvent = "pointerdown";
          moveEvent = "pointermove";
          upEvent = "pointerup";
        } else if ("ontouchstart" in window) {
          downEvent = "touchstart";
          moveEvent = "touchmove";
          upEvent = "touchend";
        }
      }
      function noop() {
      }
      function Dragger(options) {
        this.create(options || {});
      }
      Dragger.prototype.create = function(options) {
        this.onDragStart = options.onDragStart || noop;
        this.onDragMove = options.onDragMove || noop;
        this.onDragEnd = options.onDragEnd || noop;
        this.bindDrag(options.startElement);
      };
      Dragger.prototype.bindDrag = function(element) {
        element = this.getQueryElement(element);
        if (!element) {
          return;
        }
        element.style.touchAction = "none";
        element.addEventListener(downEvent, this);
      };
      Dragger.prototype.getQueryElement = function(element) {
        if (typeof element == "string") {
          element = document.querySelector(element);
        }
        return element;
      };
      Dragger.prototype.handleEvent = function(event) {
        var method = this["on" + event.type];
        if (method) {
          method.call(this, event);
        }
      };
      Dragger.prototype.onmousedown = Dragger.prototype.onpointerdown = function(event) {
        this.dragStart(event, event);
      };
      Dragger.prototype.ontouchstart = function(event) {
        this.dragStart(event, event.changedTouches[0]);
      };
      Dragger.prototype.dragStart = function(event, pointer) {
        event.preventDefault();
        this.dragStartX = pointer.pageX;
        this.dragStartY = pointer.pageY;
        if (hasWindow) {
          window.addEventListener(moveEvent, this);
          window.addEventListener(upEvent, this);
        }
        this.onDragStart(pointer);
      };
      Dragger.prototype.ontouchmove = function(event) {
        this.dragMove(event, event.changedTouches[0]);
      };
      Dragger.prototype.onmousemove = Dragger.prototype.onpointermove = function(event) {
        this.dragMove(event, event);
      };
      Dragger.prototype.dragMove = function(event, pointer) {
        event.preventDefault();
        var moveX = pointer.pageX - this.dragStartX;
        var moveY = pointer.pageY - this.dragStartY;
        this.onDragMove(pointer, moveX, moveY);
      };
      Dragger.prototype.onmouseup = Dragger.prototype.onpointerup = Dragger.prototype.ontouchend = Dragger.prototype.dragEnd = function() {
        window.removeEventListener(moveEvent, this);
        window.removeEventListener(upEvent, this);
        this.onDragEnd();
      };
      return Dragger;
    });
  }
});

// node_modules/zdog/js/illustration.js
var require_illustration = __commonJS({
  "node_modules/zdog/js/illustration.js"(exports, module) {
    (function(root, factory) {
      if (typeof module == "object" && module.exports) {
        module.exports = factory(
          require_boilerplate(),
          require_anchor(),
          require_dragger()
        );
      } else {
        var Zdog = root.Zdog;
        Zdog.Illustration = factory(Zdog, Zdog.Anchor, Zdog.Dragger);
      }
    })(exports, function factory(utils, Anchor, Dragger) {
      function noop() {
      }
      var TAU = utils.TAU;
      var Illustration = Anchor.subclass({
        element: void 0,
        centered: true,
        zoom: 1,
        dragRotate: false,
        resize: false,
        onPrerender: noop,
        onDragStart: noop,
        onDragMove: noop,
        onDragEnd: noop,
        onResize: noop
      });
      utils.extend(Illustration.prototype, Dragger.prototype);
      Illustration.prototype.create = function(options) {
        Anchor.prototype.create.call(this, options);
        Dragger.prototype.create.call(this, options);
        this.setElement(this.element);
        this.setDragRotate(this.dragRotate);
        this.setResize(this.resize);
      };
      Illustration.prototype.setElement = function(element) {
        element = this.getQueryElement(element);
        if (!element) {
          throw new Error("Zdog.Illustration element required. Set to " + element);
        }
        var nodeName = element.nodeName.toLowerCase();
        if (nodeName == "canvas") {
          this.setCanvas(element);
        } else if (nodeName == "svg") {
          this.setSvg(element);
        }
      };
      Illustration.prototype.setSize = function(width, height) {
        width = Math.round(width);
        height = Math.round(height);
        if (this.isCanvas) {
          this.setSizeCanvas(width, height);
        } else if (this.isSvg) {
          this.setSizeSvg(width, height);
        }
      };
      Illustration.prototype.setResize = function(resize) {
        this.resize = resize;
        if (!this.resizeListener) {
          this.resizeListener = this.onWindowResize.bind(this);
        }
        if (resize) {
          window.addEventListener("resize", this.resizeListener);
          this.onWindowResize();
        } else {
          window.removeEventListener("resize", this.resizeListener);
        }
      };
      Illustration.prototype.onWindowResize = function() {
        this.setMeasuredSize();
        this.onResize(this.width, this.height);
      };
      Illustration.prototype.setMeasuredSize = function() {
        var width, height;
        var isFullscreen = this.resize == "fullscreen";
        if (isFullscreen) {
          width = window.innerWidth;
          height = window.innerHeight;
        } else {
          var rect = this.element.getBoundingClientRect();
          width = rect.width;
          height = rect.height;
        }
        this.setSize(width, height);
      };
      Illustration.prototype.renderGraph = function(item) {
        if (this.isCanvas) {
          this.renderGraphCanvas(item);
        } else if (this.isSvg) {
          this.renderGraphSvg(item);
        }
      };
      Illustration.prototype.updateRenderGraph = function(item) {
        this.updateGraph();
        this.renderGraph(item);
      };
      Illustration.prototype.setCanvas = function(element) {
        this.element = element;
        this.isCanvas = true;
        this.ctx = this.element.getContext("2d");
        this.setSizeCanvas(element.width, element.height);
      };
      Illustration.prototype.setSizeCanvas = function(width, height) {
        this.width = width;
        this.height = height;
        var pixelRatio = this.pixelRatio = window.devicePixelRatio || 1;
        this.element.width = this.canvasWidth = width * pixelRatio;
        this.element.height = this.canvasHeight = height * pixelRatio;
        var needsHighPixelRatioSizing = pixelRatio > 1 && !this.resize;
        if (needsHighPixelRatioSizing) {
          this.element.style.width = width + "px";
          this.element.style.height = height + "px";
        }
      };
      Illustration.prototype.renderGraphCanvas = function(item) {
        item = item || this;
        this.prerenderCanvas();
        Anchor.prototype.renderGraphCanvas.call(item, this.ctx);
        this.postrenderCanvas();
      };
      Illustration.prototype.prerenderCanvas = function() {
        var ctx = this.ctx;
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);
        ctx.save();
        if (this.centered) {
          var centerX = this.width / 2 * this.pixelRatio;
          var centerY = this.height / 2 * this.pixelRatio;
          ctx.translate(centerX, centerY);
        }
        var scale = this.pixelRatio * this.zoom;
        ctx.scale(scale, scale);
        this.onPrerender(ctx);
      };
      Illustration.prototype.postrenderCanvas = function() {
        this.ctx.restore();
      };
      Illustration.prototype.setSvg = function(element) {
        this.element = element;
        this.isSvg = true;
        this.pixelRatio = 1;
        var width = element.getAttribute("width");
        var height = element.getAttribute("height");
        this.setSizeSvg(width, height);
      };
      Illustration.prototype.setSizeSvg = function(width, height) {
        this.width = width;
        this.height = height;
        var viewWidth = width / this.zoom;
        var viewHeight = height / this.zoom;
        var viewX = this.centered ? -viewWidth / 2 : 0;
        var viewY = this.centered ? -viewHeight / 2 : 0;
        this.element.setAttribute("viewBox", viewX + " " + viewY + " " + viewWidth + " " + viewHeight);
        if (this.resize) {
          this.element.removeAttribute("width");
          this.element.removeAttribute("height");
        } else {
          this.element.setAttribute("width", width);
          this.element.setAttribute("height", height);
        }
      };
      Illustration.prototype.renderGraphSvg = function(item) {
        item = item || this;
        empty(this.element);
        this.onPrerender(this.element);
        Anchor.prototype.renderGraphSvg.call(item, this.element);
      };
      function empty(element) {
        while (element.firstChild) {
          element.removeChild(element.firstChild);
        }
      }
      Illustration.prototype.setDragRotate = function(item) {
        if (!item) {
          return;
        } else if (item === true) {
          item = this;
        }
        this.dragRotate = item;
        this.bindDrag(this.element);
      };
      Illustration.prototype.dragStart = function() {
        this.dragStartRX = this.dragRotate.rotate.x;
        this.dragStartRY = this.dragRotate.rotate.y;
        Dragger.prototype.dragStart.apply(this, arguments);
      };
      Illustration.prototype.dragMove = function(event, pointer) {
        var moveX = pointer.pageX - this.dragStartX;
        var moveY = pointer.pageY - this.dragStartY;
        var displaySize = Math.min(this.width, this.height);
        var moveRY = moveX / displaySize * TAU;
        var moveRX = moveY / displaySize * TAU;
        this.dragRotate.rotate.x = this.dragStartRX - moveRX;
        this.dragRotate.rotate.y = this.dragStartRY - moveRY;
        Dragger.prototype.dragMove.apply(this, arguments);
      };
      return Illustration;
    });
  }
});

// node_modules/zdog/js/path-command.js
var require_path_command = __commonJS({
  "node_modules/zdog/js/path-command.js"(exports, module) {
    (function(root, factory) {
      if (typeof module == "object" && module.exports) {
        module.exports = factory(require_vector());
      } else {
        var Zdog = root.Zdog;
        Zdog.PathCommand = factory(Zdog.Vector);
      }
    })(exports, function factory(Vector) {
      function PathCommand(method, points, previousPoint) {
        this.method = method;
        this.points = points.map(mapVectorPoint);
        this.renderPoints = points.map(mapNewVector);
        this.previousPoint = previousPoint;
        this.endRenderPoint = this.renderPoints[this.renderPoints.length - 1];
        if (method == "arc") {
          this.controlPoints = [new Vector(), new Vector()];
        }
      }
      function mapVectorPoint(point) {
        if (point instanceof Vector) {
          return point;
        } else {
          return new Vector(point);
        }
      }
      function mapNewVector(point) {
        return new Vector(point);
      }
      PathCommand.prototype.reset = function() {
        var points = this.points;
        this.renderPoints.forEach(function(renderPoint, i) {
          var point = points[i];
          renderPoint.set(point);
        });
      };
      PathCommand.prototype.transform = function(translation, rotation, scale) {
        this.renderPoints.forEach(function(renderPoint) {
          renderPoint.transform(translation, rotation, scale);
        });
      };
      PathCommand.prototype.render = function(ctx, elem, renderer) {
        return this[this.method](ctx, elem, renderer);
      };
      PathCommand.prototype.move = function(ctx, elem, renderer) {
        return renderer.move(ctx, elem, this.renderPoints[0]);
      };
      PathCommand.prototype.line = function(ctx, elem, renderer) {
        return renderer.line(ctx, elem, this.renderPoints[0]);
      };
      PathCommand.prototype.bezier = function(ctx, elem, renderer) {
        var cp0 = this.renderPoints[0];
        var cp1 = this.renderPoints[1];
        var end = this.renderPoints[2];
        return renderer.bezier(ctx, elem, cp0, cp1, end);
      };
      var arcHandleLength = 9 / 16;
      PathCommand.prototype.arc = function(ctx, elem, renderer) {
        var prev = this.previousPoint;
        var corner = this.renderPoints[0];
        var end = this.renderPoints[1];
        var cp0 = this.controlPoints[0];
        var cp1 = this.controlPoints[1];
        cp0.set(prev).lerp(corner, arcHandleLength);
        cp1.set(end).lerp(corner, arcHandleLength);
        return renderer.bezier(ctx, elem, cp0, cp1, end);
      };
      return PathCommand;
    });
  }
});

// node_modules/zdog/js/shape.js
var require_shape = __commonJS({
  "node_modules/zdog/js/shape.js"(exports, module) {
    (function(root, factory) {
      if (typeof module == "object" && module.exports) {
        module.exports = factory(
          require_boilerplate(),
          require_vector(),
          require_path_command(),
          require_anchor()
        );
      } else {
        var Zdog = root.Zdog;
        Zdog.Shape = factory(Zdog, Zdog.Vector, Zdog.PathCommand, Zdog.Anchor);
      }
    })(exports, function factory(utils, Vector, PathCommand, Anchor) {
      var Shape = Anchor.subclass({
        stroke: 1,
        fill: false,
        color: "#333",
        closed: true,
        visible: true,
        path: [{}],
        front: { z: 1 },
        backface: true
      });
      Shape.prototype.create = function(options) {
        Anchor.prototype.create.call(this, options);
        this.updatePath();
        this.front = new Vector(options.front || this.front);
        this.renderFront = new Vector(this.front);
        this.renderNormal = new Vector();
      };
      var actionNames = [
        "move",
        "line",
        "bezier",
        "arc"
      ];
      Shape.prototype.updatePath = function() {
        this.setPath();
        this.updatePathCommands();
      };
      Shape.prototype.setPath = function() {
      };
      Shape.prototype.updatePathCommands = function() {
        var previousPoint;
        this.pathCommands = this.path.map(function(pathPart, i) {
          var keys = Object.keys(pathPart);
          var method = keys[0];
          var points = pathPart[method];
          var isInstruction = keys.length == 1 && actionNames.indexOf(method) != -1;
          if (!isInstruction) {
            method = "line";
            points = pathPart;
          }
          var isLineOrMove = method == "line" || method == "move";
          var isPointsArray = Array.isArray(points);
          if (isLineOrMove && !isPointsArray) {
            points = [points];
          }
          method = i === 0 ? "move" : method;
          var command = new PathCommand(method, points, previousPoint);
          previousPoint = command.endRenderPoint;
          return command;
        });
      };
      Shape.prototype.reset = function() {
        this.renderOrigin.set(this.origin);
        this.renderFront.set(this.front);
        this.pathCommands.forEach(function(command) {
          command.reset();
        });
      };
      Shape.prototype.transform = function(translation, rotation, scale) {
        this.renderOrigin.transform(translation, rotation, scale);
        this.renderFront.transform(translation, rotation, scale);
        this.renderNormal.set(this.renderOrigin).subtract(this.renderFront);
        this.pathCommands.forEach(function(command) {
          command.transform(translation, rotation, scale);
        });
        this.children.forEach(function(child) {
          child.transform(translation, rotation, scale);
        });
      };
      Shape.prototype.updateSortValue = function() {
        var pointCount = this.pathCommands.length;
        var firstPoint = this.pathCommands[0].endRenderPoint;
        var lastPoint = this.pathCommands[pointCount - 1].endRenderPoint;
        var isSelfClosing = pointCount > 2 && firstPoint.isSame(lastPoint);
        if (isSelfClosing) {
          pointCount -= 1;
        }
        var sortValueTotal = 0;
        for (var i = 0; i < pointCount; i++) {
          sortValueTotal += this.pathCommands[i].endRenderPoint.z;
        }
        this.sortValue = sortValueTotal / pointCount;
      };
      Shape.prototype.render = function(ctx, renderer) {
        var length = this.pathCommands.length;
        if (!this.visible || !length) {
          return;
        }
        this.isFacingBack = this.renderNormal.z > 0;
        if (!this.backface && this.isFacingBack) {
          return;
        }
        if (!renderer) {
          throw new Error("Zdog renderer required. Set to " + renderer);
        }
        var isDot = length == 1;
        if (renderer.isCanvas && isDot) {
          this.renderCanvasDot(ctx, renderer);
        } else {
          this.renderPath(ctx, renderer);
        }
      };
      var TAU = utils.TAU;
      Shape.prototype.renderCanvasDot = function(ctx) {
        var lineWidth = this.getLineWidth();
        if (!lineWidth) {
          return;
        }
        ctx.fillStyle = this.getRenderColor();
        var point = this.pathCommands[0].endRenderPoint;
        ctx.beginPath();
        var radius = lineWidth / 2;
        ctx.arc(point.x, point.y, radius, 0, TAU);
        ctx.fill();
      };
      Shape.prototype.getLineWidth = function() {
        if (!this.stroke) {
          return 0;
        }
        if (this.stroke == true) {
          return 1;
        }
        return this.stroke;
      };
      Shape.prototype.getRenderColor = function() {
        var isBackfaceColor = typeof this.backface == "string" && this.isFacingBack;
        var color = isBackfaceColor ? this.backface : this.color;
        return color;
      };
      Shape.prototype.renderPath = function(ctx, renderer) {
        var elem = this.getRenderElement(ctx, renderer);
        var isTwoPoints = this.pathCommands.length == 2 && this.pathCommands[1].method == "line";
        var isClosed = !isTwoPoints && this.closed;
        var color = this.getRenderColor();
        renderer.renderPath(ctx, elem, this.pathCommands, isClosed);
        renderer.stroke(ctx, elem, this.stroke, color, this.getLineWidth());
        renderer.fill(ctx, elem, this.fill, color);
        renderer.end(ctx, elem);
      };
      var svgURI = "http://www.w3.org/2000/svg";
      Shape.prototype.getRenderElement = function(ctx, renderer) {
        if (!renderer.isSvg) {
          return;
        }
        if (!this.svgElement) {
          this.svgElement = document.createElementNS(svgURI, "path");
          this.svgElement.setAttribute("stroke-linecap", "round");
          this.svgElement.setAttribute("stroke-linejoin", "round");
        }
        return this.svgElement;
      };
      return Shape;
    });
  }
});

// node_modules/zdog/js/group.js
var require_group = __commonJS({
  "node_modules/zdog/js/group.js"(exports, module) {
    (function(root, factory) {
      if (typeof module == "object" && module.exports) {
        module.exports = factory(require_anchor());
      } else {
        var Zdog = root.Zdog;
        Zdog.Group = factory(Zdog.Anchor);
      }
    })(exports, function factory(Anchor) {
      var Group = Anchor.subclass({
        updateSort: false,
        visible: true
      });
      Group.prototype.updateSortValue = function() {
        var sortValueTotal = 0;
        this.flatGraph.forEach(function(item) {
          item.updateSortValue();
          sortValueTotal += item.sortValue;
        });
        this.sortValue = sortValueTotal / this.flatGraph.length;
        if (this.updateSort) {
          this.flatGraph.sort(Anchor.shapeSorter);
        }
      };
      Group.prototype.render = function(ctx, renderer) {
        if (!this.visible) {
          return;
        }
        this.flatGraph.forEach(function(item) {
          item.render(ctx, renderer);
        });
      };
      Group.prototype.updateFlatGraph = function() {
        var flatGraph = [];
        this.flatGraph = this.addChildFlatGraph(flatGraph);
      };
      Group.prototype.getFlatGraph = function() {
        return [this];
      };
      return Group;
    });
  }
});

// node_modules/zdog/js/rect.js
var require_rect = __commonJS({
  "node_modules/zdog/js/rect.js"(exports, module) {
    (function(root, factory) {
      if (typeof module == "object" && module.exports) {
        module.exports = factory(require_shape());
      } else {
        var Zdog = root.Zdog;
        Zdog.Rect = factory(Zdog.Shape);
      }
    })(exports, function factory(Shape) {
      var Rect = Shape.subclass({
        width: 1,
        height: 1
      });
      Rect.prototype.setPath = function() {
        var x = this.width / 2;
        var y = this.height / 2;
        this.path = [
          { x: -x, y: -y },
          { x, y: -y },
          { x, y },
          { x: -x, y }
        ];
      };
      return Rect;
    });
  }
});

// node_modules/zdog/js/rounded-rect.js
var require_rounded_rect = __commonJS({
  "node_modules/zdog/js/rounded-rect.js"(exports, module) {
    (function(root, factory) {
      if (typeof module == "object" && module.exports) {
        module.exports = factory(require_shape());
      } else {
        var Zdog = root.Zdog;
        Zdog.RoundedRect = factory(Zdog.Shape);
      }
    })(exports, function factory(Shape) {
      var RoundedRect = Shape.subclass({
        width: 1,
        height: 1,
        cornerRadius: 0.25,
        closed: false
      });
      RoundedRect.prototype.setPath = function() {
        var xA = this.width / 2;
        var yA = this.height / 2;
        var shortSide = Math.min(xA, yA);
        var cornerRadius = Math.min(this.cornerRadius, shortSide);
        var xB = xA - cornerRadius;
        var yB = yA - cornerRadius;
        var path = [
          // top right corner
          { x: xB, y: -yA },
          { arc: [
            { x: xA, y: -yA },
            { x: xA, y: -yB }
          ] }
        ];
        if (yB) {
          path.push({ x: xA, y: yB });
        }
        path.push({ arc: [
          { x: xA, y: yA },
          { x: xB, y: yA }
        ] });
        if (xB) {
          path.push({ x: -xB, y: yA });
        }
        path.push({ arc: [
          { x: -xA, y: yA },
          { x: -xA, y: yB }
        ] });
        if (yB) {
          path.push({ x: -xA, y: -yB });
        }
        path.push({ arc: [
          { x: -xA, y: -yA },
          { x: -xB, y: -yA }
        ] });
        if (xB) {
          path.push({ x: xB, y: -yA });
        }
        this.path = path;
      };
      return RoundedRect;
    });
  }
});

// node_modules/zdog/js/ellipse.js
var require_ellipse = __commonJS({
  "node_modules/zdog/js/ellipse.js"(exports, module) {
    (function(root, factory) {
      if (typeof module == "object" && module.exports) {
        module.exports = factory(require_shape());
      } else {
        var Zdog = root.Zdog;
        Zdog.Ellipse = factory(Zdog.Shape);
      }
    })(exports, function factory(Shape) {
      var Ellipse = Shape.subclass({
        diameter: 1,
        width: void 0,
        height: void 0,
        quarters: 4,
        closed: false
      });
      Ellipse.prototype.setPath = function() {
        var width = this.width != void 0 ? this.width : this.diameter;
        var height = this.height != void 0 ? this.height : this.diameter;
        var x = width / 2;
        var y = height / 2;
        this.path = [
          { x: 0, y: -y },
          { arc: [
            // top right
            { x, y: -y },
            { x, y: 0 }
          ] }
        ];
        if (this.quarters > 1) {
          this.path.push({ arc: [
            { x, y },
            { x: 0, y }
          ] });
        }
        if (this.quarters > 2) {
          this.path.push({ arc: [
            { x: -x, y },
            { x: -x, y: 0 }
          ] });
        }
        if (this.quarters > 3) {
          this.path.push({ arc: [
            { x: -x, y: -y },
            { x: 0, y: -y }
          ] });
        }
      };
      return Ellipse;
    });
  }
});

// node_modules/zdog/js/polygon.js
var require_polygon = __commonJS({
  "node_modules/zdog/js/polygon.js"(exports, module) {
    (function(root, factory) {
      if (typeof module == "object" && module.exports) {
        module.exports = factory(require_boilerplate(), require_shape());
      } else {
        var Zdog = root.Zdog;
        Zdog.Polygon = factory(Zdog, Zdog.Shape);
      }
    })(exports, function factory(utils, Shape) {
      var Polygon = Shape.subclass({
        sides: 3,
        radius: 0.5
      });
      var TAU = utils.TAU;
      Polygon.prototype.setPath = function() {
        this.path = [];
        for (var i = 0; i < this.sides; i++) {
          var theta = i / this.sides * TAU - TAU / 4;
          var x = Math.cos(theta) * this.radius;
          var y = Math.sin(theta) * this.radius;
          this.path.push({ x, y });
        }
      };
      return Polygon;
    });
  }
});

// node_modules/zdog/js/hemisphere.js
var require_hemisphere = __commonJS({
  "node_modules/zdog/js/hemisphere.js"(exports, module) {
    (function(root, factory) {
      if (typeof module == "object" && module.exports) {
        module.exports = factory(
          require_boilerplate(),
          require_vector(),
          require_anchor(),
          require_ellipse()
        );
      } else {
        var Zdog = root.Zdog;
        Zdog.Hemisphere = factory(Zdog, Zdog.Vector, Zdog.Anchor, Zdog.Ellipse);
      }
    })(exports, function factory(utils, Vector, Anchor, Ellipse) {
      var Hemisphere = Ellipse.subclass({
        fill: true
      });
      var TAU = utils.TAU;
      Hemisphere.prototype.create = function() {
        Ellipse.prototype.create.apply(this, arguments);
        this.apex = new Anchor({
          addTo: this,
          translate: { z: this.diameter / 2 }
        });
        this.renderCentroid = new Vector();
      };
      Hemisphere.prototype.updateSortValue = function() {
        this.renderCentroid.set(this.renderOrigin).lerp(this.apex.renderOrigin, 3 / 8);
        this.sortValue = this.renderCentroid.z;
      };
      Hemisphere.prototype.render = function(ctx, renderer) {
        this.renderDome(ctx, renderer);
        Ellipse.prototype.render.apply(this, arguments);
      };
      Hemisphere.prototype.renderDome = function(ctx, renderer) {
        if (!this.visible) {
          return;
        }
        var elem = this.getDomeRenderElement(ctx, renderer);
        var contourAngle = Math.atan2(this.renderNormal.y, this.renderNormal.x);
        var domeRadius = this.diameter / 2 * this.renderNormal.magnitude();
        var x = this.renderOrigin.x;
        var y = this.renderOrigin.y;
        if (renderer.isCanvas) {
          var startAngle = contourAngle + TAU / 4;
          var endAngle = contourAngle - TAU / 4;
          ctx.beginPath();
          ctx.arc(x, y, domeRadius, startAngle, endAngle);
        } else if (renderer.isSvg) {
          contourAngle = (contourAngle - TAU / 4) / TAU * 360;
          this.domeSvgElement.setAttribute("d", "M " + -domeRadius + ",0 A " + domeRadius + "," + domeRadius + " 0 0 1 " + domeRadius + ",0");
          this.domeSvgElement.setAttribute(
            "transform",
            "translate(" + x + "," + y + " ) rotate(" + contourAngle + ")"
          );
        }
        renderer.stroke(ctx, elem, this.stroke, this.color, this.getLineWidth());
        renderer.fill(ctx, elem, this.fill, this.color);
        renderer.end(ctx, elem);
      };
      var svgURI = "http://www.w3.org/2000/svg";
      Hemisphere.prototype.getDomeRenderElement = function(ctx, renderer) {
        if (!renderer.isSvg) {
          return;
        }
        if (!this.domeSvgElement) {
          this.domeSvgElement = document.createElementNS(svgURI, "path");
          this.domeSvgElement.setAttribute("stroke-linecap", "round");
          this.domeSvgElement.setAttribute("stroke-linejoin", "round");
        }
        return this.domeSvgElement;
      };
      return Hemisphere;
    });
  }
});

// node_modules/zdog/js/cylinder.js
var require_cylinder = __commonJS({
  "node_modules/zdog/js/cylinder.js"(exports, module) {
    (function(root, factory) {
      if (typeof module == "object" && module.exports) {
        module.exports = factory(
          require_boilerplate(),
          require_path_command(),
          require_shape(),
          require_group(),
          require_ellipse()
        );
      } else {
        var Zdog = root.Zdog;
        Zdog.Cylinder = factory(
          Zdog,
          Zdog.PathCommand,
          Zdog.Shape,
          Zdog.Group,
          Zdog.Ellipse
        );
      }
    })(exports, function factory(utils, PathCommand, Shape, Group, Ellipse) {
      function noop() {
      }
      var CylinderGroup = Group.subclass({
        color: "#333",
        updateSort: true
      });
      CylinderGroup.prototype.create = function() {
        Group.prototype.create.apply(this, arguments);
        this.pathCommands = [
          new PathCommand("move", [{}]),
          new PathCommand("line", [{}])
        ];
      };
      CylinderGroup.prototype.render = function(ctx, renderer) {
        this.renderCylinderSurface(ctx, renderer);
        Group.prototype.render.apply(this, arguments);
      };
      CylinderGroup.prototype.renderCylinderSurface = function(ctx, renderer) {
        if (!this.visible) {
          return;
        }
        var elem = this.getRenderElement(ctx, renderer);
        var frontBase = this.frontBase;
        var rearBase = this.rearBase;
        var scale = frontBase.renderNormal.magnitude();
        var strokeWidth = frontBase.diameter * scale + frontBase.getLineWidth();
        this.pathCommands[0].renderPoints[0].set(frontBase.renderOrigin);
        this.pathCommands[1].renderPoints[0].set(rearBase.renderOrigin);
        if (renderer.isCanvas) {
          ctx.lineCap = "butt";
        }
        renderer.renderPath(ctx, elem, this.pathCommands);
        renderer.stroke(ctx, elem, true, this.color, strokeWidth);
        renderer.end(ctx, elem);
        if (renderer.isCanvas) {
          ctx.lineCap = "round";
        }
      };
      var svgURI = "http://www.w3.org/2000/svg";
      CylinderGroup.prototype.getRenderElement = function(ctx, renderer) {
        if (!renderer.isSvg) {
          return;
        }
        if (!this.svgElement) {
          this.svgElement = document.createElementNS(svgURI, "path");
        }
        return this.svgElement;
      };
      CylinderGroup.prototype.copyGraph = noop;
      var CylinderEllipse = Ellipse.subclass();
      CylinderEllipse.prototype.copyGraph = noop;
      var Cylinder = Shape.subclass({
        diameter: 1,
        length: 1,
        frontFace: void 0,
        fill: true
      });
      var TAU = utils.TAU;
      Cylinder.prototype.create = function() {
        Shape.prototype.create.apply(this, arguments);
        this.group = new CylinderGroup({
          addTo: this,
          color: this.color,
          visible: this.visible
        });
        var baseZ = this.length / 2;
        var baseColor = this.backface || true;
        this.frontBase = this.group.frontBase = new Ellipse({
          addTo: this.group,
          diameter: this.diameter,
          translate: { z: baseZ },
          rotate: { y: TAU / 2 },
          color: this.color,
          stroke: this.stroke,
          fill: this.fill,
          backface: this.frontFace || baseColor,
          visible: this.visible
        });
        this.rearBase = this.group.rearBase = this.frontBase.copy({
          translate: { z: -baseZ },
          rotate: { y: 0 },
          backface: baseColor
        });
      };
      Cylinder.prototype.render = function() {
      };
      var childProperties = ["stroke", "fill", "color", "visible"];
      childProperties.forEach(function(property) {
        var _prop = "_" + property;
        Object.defineProperty(Cylinder.prototype, property, {
          get: function() {
            return this[_prop];
          },
          set: function(value) {
            this[_prop] = value;
            if (this.frontBase) {
              this.frontBase[property] = value;
              this.rearBase[property] = value;
              this.group[property] = value;
            }
          }
        });
      });
      return Cylinder;
    });
  }
});

// node_modules/zdog/js/cone.js
var require_cone = __commonJS({
  "node_modules/zdog/js/cone.js"(exports, module) {
    (function(root, factory) {
      if (typeof module == "object" && module.exports) {
        module.exports = factory(
          require_boilerplate(),
          require_vector(),
          require_path_command(),
          require_anchor(),
          require_ellipse()
        );
      } else {
        var Zdog = root.Zdog;
        Zdog.Cone = factory(
          Zdog,
          Zdog.Vector,
          Zdog.PathCommand,
          Zdog.Anchor,
          Zdog.Ellipse
        );
      }
    })(exports, function factory(utils, Vector, PathCommand, Anchor, Ellipse) {
      var Cone = Ellipse.subclass({
        length: 1,
        fill: true
      });
      var TAU = utils.TAU;
      Cone.prototype.create = function() {
        Ellipse.prototype.create.apply(this, arguments);
        this.apex = new Anchor({
          addTo: this,
          translate: { z: this.length }
        });
        this.renderApex = new Vector();
        this.renderCentroid = new Vector();
        this.tangentA = new Vector();
        this.tangentB = new Vector();
        this.surfacePathCommands = [
          new PathCommand("move", [{}]),
          // points set in renderConeSurface
          new PathCommand("line", [{}]),
          new PathCommand("line", [{}])
        ];
      };
      Cone.prototype.updateSortValue = function() {
        this.renderCentroid.set(this.renderOrigin).lerp(this.apex.renderOrigin, 1 / 3);
        this.sortValue = this.renderCentroid.z;
      };
      Cone.prototype.render = function(ctx, renderer) {
        this.renderConeSurface(ctx, renderer);
        Ellipse.prototype.render.apply(this, arguments);
      };
      Cone.prototype.renderConeSurface = function(ctx, renderer) {
        if (!this.visible) {
          return;
        }
        this.renderApex.set(this.apex.renderOrigin).subtract(this.renderOrigin);
        var scale = this.renderNormal.magnitude();
        var apexDistance = this.renderApex.magnitude2d();
        var normalDistance = this.renderNormal.magnitude2d();
        var eccenAngle = Math.acos(normalDistance / scale);
        var eccen = Math.sin(eccenAngle);
        var radius = this.diameter / 2 * scale;
        var isApexVisible = radius * eccen < apexDistance;
        if (!isApexVisible) {
          return;
        }
        var apexAngle = Math.atan2(this.renderNormal.y, this.renderNormal.x) + TAU / 2;
        var projectLength = apexDistance / eccen;
        var projectAngle = Math.acos(radius / projectLength);
        var tangentA = this.tangentA;
        var tangentB = this.tangentB;
        tangentA.x = Math.cos(projectAngle) * radius * eccen;
        tangentA.y = Math.sin(projectAngle) * radius;
        tangentB.set(this.tangentA);
        tangentB.y *= -1;
        tangentA.rotateZ(apexAngle);
        tangentB.rotateZ(apexAngle);
        tangentA.add(this.renderOrigin);
        tangentB.add(this.renderOrigin);
        this.setSurfaceRenderPoint(0, tangentA);
        this.setSurfaceRenderPoint(1, this.apex.renderOrigin);
        this.setSurfaceRenderPoint(2, tangentB);
        var elem = this.getSurfaceRenderElement(ctx, renderer);
        renderer.renderPath(ctx, elem, this.surfacePathCommands);
        renderer.stroke(ctx, elem, this.stroke, this.color, this.getLineWidth());
        renderer.fill(ctx, elem, this.fill, this.color);
        renderer.end(ctx, elem);
      };
      var svgURI = "http://www.w3.org/2000/svg";
      Cone.prototype.getSurfaceRenderElement = function(ctx, renderer) {
        if (!renderer.isSvg) {
          return;
        }
        if (!this.surfaceSvgElement) {
          this.surfaceSvgElement = document.createElementNS(svgURI, "path");
          this.surfaceSvgElement.setAttribute("stroke-linecap", "round");
          this.surfaceSvgElement.setAttribute("stroke-linejoin", "round");
        }
        return this.surfaceSvgElement;
      };
      Cone.prototype.setSurfaceRenderPoint = function(index, point) {
        var renderPoint = this.surfacePathCommands[index].renderPoints[0];
        renderPoint.set(point);
      };
      return Cone;
    });
  }
});

// node_modules/zdog/js/box.js
var require_box = __commonJS({
  "node_modules/zdog/js/box.js"(exports, module) {
    (function(root, factory) {
      if (typeof module == "object" && module.exports) {
        module.exports = factory(
          require_boilerplate(),
          require_anchor(),
          require_shape(),
          require_rect()
        );
      } else {
        var Zdog = root.Zdog;
        Zdog.Box = factory(Zdog, Zdog.Anchor, Zdog.Shape, Zdog.Rect);
      }
    })(exports, function factory(utils, Anchor, Shape, Rect) {
      var BoxRect = Rect.subclass();
      BoxRect.prototype.copyGraph = function() {
      };
      var TAU = utils.TAU;
      var faceNames = [
        "frontFace",
        "rearFace",
        "leftFace",
        "rightFace",
        "topFace",
        "bottomFace"
      ];
      var boxDefaults = utils.extend({}, Shape.defaults);
      delete boxDefaults.path;
      faceNames.forEach(function(faceName) {
        boxDefaults[faceName] = true;
      });
      utils.extend(boxDefaults, {
        width: 1,
        height: 1,
        depth: 1,
        fill: true
      });
      var Box = Anchor.subclass(boxDefaults);
      Box.prototype.create = function(options) {
        Anchor.prototype.create.call(this, options);
        this.updatePath();
        this.fill = this.fill;
      };
      Box.prototype.updatePath = function() {
        faceNames.forEach(function(faceName) {
          this[faceName] = this[faceName];
        }, this);
      };
      faceNames.forEach(function(faceName) {
        var _faceName = "_" + faceName;
        Object.defineProperty(Box.prototype, faceName, {
          get: function() {
            return this[_faceName];
          },
          set: function(value) {
            this[_faceName] = value;
            this.setFace(faceName, value);
          }
        });
      });
      Box.prototype.setFace = function(faceName, value) {
        var rectProperty = faceName + "Rect";
        var rect = this[rectProperty];
        if (!value) {
          this.removeChild(rect);
          return;
        }
        var options = this.getFaceOptions(faceName);
        options.color = typeof value == "string" ? value : this.color;
        if (rect) {
          rect.setOptions(options);
        } else {
          rect = this[rectProperty] = new BoxRect(options);
        }
        rect.updatePath();
        this.addChild(rect);
      };
      Box.prototype.getFaceOptions = function(faceName) {
        return {
          frontFace: {
            width: this.width,
            height: this.height,
            translate: { z: this.depth / 2 }
          },
          rearFace: {
            width: this.width,
            height: this.height,
            translate: { z: -this.depth / 2 },
            rotate: { y: TAU / 2 }
          },
          leftFace: {
            width: this.depth,
            height: this.height,
            translate: { x: -this.width / 2 },
            rotate: { y: -TAU / 4 }
          },
          rightFace: {
            width: this.depth,
            height: this.height,
            translate: { x: this.width / 2 },
            rotate: { y: TAU / 4 }
          },
          topFace: {
            width: this.width,
            height: this.depth,
            translate: { y: -this.height / 2 },
            rotate: { x: -TAU / 4 }
          },
          bottomFace: {
            width: this.width,
            height: this.depth,
            translate: { y: this.height / 2 },
            rotate: { x: TAU / 4 }
          }
        }[faceName];
      };
      var childProperties = [
        "color",
        "stroke",
        "fill",
        "backface",
        "front",
        "visible"
      ];
      childProperties.forEach(function(property) {
        var _prop = "_" + property;
        Object.defineProperty(Box.prototype, property, {
          get: function() {
            return this[_prop];
          },
          set: function(value) {
            this[_prop] = value;
            faceNames.forEach(function(faceName) {
              var rect = this[faceName + "Rect"];
              var isFaceColor = typeof this[faceName] == "string";
              var isColorUnderwrite = property == "color" && isFaceColor;
              if (rect && !isColorUnderwrite) {
                rect[property] = value;
              }
            }, this);
          }
        });
      });
      return Box;
    });
  }
});

// node_modules/zdog/js/index.js
var require_js = __commonJS({
  "node_modules/zdog/js/index.js"(exports, module) {
    (function(root, factory) {
      if (typeof module == "object" && module.exports) {
        module.exports = factory(
          require_boilerplate(),
          require_canvas_renderer(),
          require_svg_renderer(),
          require_vector(),
          require_anchor(),
          require_dragger(),
          require_illustration(),
          require_path_command(),
          require_shape(),
          require_group(),
          require_rect(),
          require_rounded_rect(),
          require_ellipse(),
          require_polygon(),
          require_hemisphere(),
          require_cylinder(),
          require_cone(),
          require_box()
        );
      } else if (typeof define == "function" && define.amd) {
        define("zdog", [], root.Zdog);
      }
    })(exports, function factory(Zdog, CanvasRenderer, SvgRenderer, Vector, Anchor, Dragger, Illustration, PathCommand, Shape, Group, Rect, RoundedRect, Ellipse, Polygon, Hemisphere, Cylinder, Cone, Box) {
      Zdog.CanvasRenderer = CanvasRenderer;
      Zdog.SvgRenderer = SvgRenderer;
      Zdog.Vector = Vector;
      Zdog.Anchor = Anchor;
      Zdog.Dragger = Dragger;
      Zdog.Illustration = Illustration;
      Zdog.PathCommand = PathCommand;
      Zdog.Shape = Shape;
      Zdog.Group = Group;
      Zdog.Rect = Rect;
      Zdog.RoundedRect = RoundedRect;
      Zdog.Ellipse = Ellipse;
      Zdog.Polygon = Polygon;
      Zdog.Hemisphere = Hemisphere;
      Zdog.Cylinder = Cylinder;
      Zdog.Cone = Cone;
      Zdog.Box = Box;
      return Zdog;
    });
  }
});

// node_modules/react-zdog/dist/react-zdog.es.js
var import_zdog = __toESM(require_js());
var import_react = __toESM(require_react());
var Ce = { exports: {} };
var Q = {};
var Xe;
function Lt() {
  return Xe || (Xe = 1, function() {
    var r = import_react.default, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), o = Symbol.for("react.fragment"), a = Symbol.for("react.strict_mode"), c = Symbol.for("react.profiler"), g = Symbol.for("react.provider"), f = Symbol.for("react.context"), b = Symbol.for("react.forward_ref"), y = Symbol.for("react.suspense"), h = Symbol.for("react.suspense_list"), x = Symbol.for("react.memo"), T = Symbol.for("react.lazy"), z = Symbol.for("react.offscreen"), W = Symbol.iterator, N = "@@iterator";
    function P(e) {
      if (e === null || typeof e != "object")
        return null;
      var i = W && e[W] || e[N];
      return typeof i == "function" ? i : null;
    }
    var G = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(e) {
      {
        for (var i = arguments.length, s = new Array(i > 1 ? i - 1 : 0), u = 1; u < i; u++)
          s[u - 1] = arguments[u];
        he("error", e, s);
      }
    }
    function he(e, i, s) {
      {
        var u = G.ReactDebugCurrentFrame, p = u.getStackAddendum();
        p !== "" && (i += "%s", s = s.concat([p]));
        var m = s.map(function(v) {
          return String(v);
        });
        m.unshift("Warning: " + i), Function.prototype.apply.call(console[e], console, m);
      }
    }
    var l = false, pe = false, D = false, K = false, be = false, re;
    re = Symbol.for("react.module.reference");
    function O(e) {
      return !!(typeof e == "string" || typeof e == "function" || e === o || e === c || be || e === a || e === y || e === h || K || e === z || l || pe || D || typeof e == "object" && e !== null && (e.$$typeof === T || e.$$typeof === x || e.$$typeof === g || e.$$typeof === f || e.$$typeof === b || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      e.$$typeof === re || e.getModuleId !== void 0));
    }
    function F(e, i, s) {
      var u = e.displayName;
      if (u)
        return u;
      var p = i.displayName || i.name || "";
      return p !== "" ? s + "(" + p + ")" : s;
    }
    function $(e) {
      return e.displayName || "Context";
    }
    function _(e) {
      if (e == null)
        return null;
      if (typeof e.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof e == "function")
        return e.displayName || e.name || null;
      if (typeof e == "string")
        return e;
      switch (e) {
        case o:
          return "Fragment";
        case n:
          return "Portal";
        case c:
          return "Profiler";
        case a:
          return "StrictMode";
        case y:
          return "Suspense";
        case h:
          return "SuspenseList";
      }
      if (typeof e == "object")
        switch (e.$$typeof) {
          case f:
            var i = e;
            return $(i) + ".Consumer";
          case g:
            var s = e;
            return $(s._context) + ".Provider";
          case b:
            return F(e, e.render, "ForwardRef");
          case x:
            var u = e.displayName || null;
            return u !== null ? u : _(e.type) || "Memo";
          case T: {
            var p = e, m = p._payload, v = p._init;
            try {
              return _(v(m));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var C = Object.assign, j = 0, ne, Se, Me, je, ke, Ae, De;
    function Fe() {
    }
    Fe.__reactDisabledLog = true;
    function ft() {
      {
        if (j === 0) {
          ne = console.log, Se = console.info, Me = console.warn, je = console.error, ke = console.group, Ae = console.groupCollapsed, De = console.groupEnd;
          var e = {
            configurable: true,
            enumerable: true,
            value: Fe,
            writable: true
          };
          Object.defineProperties(console, {
            info: e,
            log: e,
            warn: e,
            error: e,
            group: e,
            groupCollapsed: e,
            groupEnd: e
          });
        }
        j++;
      }
    }
    function dt() {
      {
        if (j--, j === 0) {
          var e = {
            configurable: true,
            enumerable: true,
            writable: true
          };
          Object.defineProperties(console, {
            log: C({}, e, {
              value: ne
            }),
            info: C({}, e, {
              value: Se
            }),
            warn: C({}, e, {
              value: Me
            }),
            error: C({}, e, {
              value: je
            }),
            group: C({}, e, {
              value: ke
            }),
            groupCollapsed: C({}, e, {
              value: Ae
            }),
            groupEnd: C({}, e, {
              value: De
            })
          });
        }
        j < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var ge = G.ReactCurrentDispatcher, me;
    function ie(e, i, s) {
      {
        if (me === void 0)
          try {
            throw Error();
          } catch (p) {
            var u = p.stack.trim().match(/\n( *(at )?)/);
            me = u && u[1] || "";
          }
        return `
` + me + e;
      }
    }
    var _e = false, oe;
    {
      var vt = typeof WeakMap == "function" ? WeakMap : Map;
      oe = new vt();
    }
    function Ie(e, i) {
      if (!e || _e)
        return "";
      {
        var s = oe.get(e);
        if (s !== void 0)
          return s;
      }
      var u;
      _e = true;
      var p = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var m;
      m = ge.current, ge.current = null, ft();
      try {
        if (i) {
          var v = function() {
            throw Error();
          };
          if (Object.defineProperty(v.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(v, []);
            } catch (I) {
              u = I;
            }
            Reflect.construct(e, [], v);
          } else {
            try {
              v.call();
            } catch (I) {
              u = I;
            }
            e.call(v.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (I) {
            u = I;
          }
          e();
        }
      } catch (I) {
        if (I && u && typeof I.stack == "string") {
          for (var d = I.stack.split(`
`), S = u.stack.split(`
`), E = d.length - 1, R = S.length - 1; E >= 1 && R >= 0 && d[E] !== S[R]; )
            R--;
          for (; E >= 1 && R >= 0; E--, R--)
            if (d[E] !== S[R]) {
              if (E !== 1 || R !== 1)
                do
                  if (E--, R--, R < 0 || d[E] !== S[R]) {
                    var k = `
` + d[E].replace(" at new ", " at ");
                    return e.displayName && k.includes("<anonymous>") && (k = k.replace("<anonymous>", e.displayName)), typeof e == "function" && oe.set(e, k), k;
                  }
                while (E >= 1 && R >= 0);
              break;
            }
        }
      } finally {
        _e = false, ge.current = m, dt(), Error.prepareStackTrace = p;
      }
      var U = e ? e.displayName || e.name : "", Je = U ? ie(U) : "";
      return typeof e == "function" && oe.set(e, Je), Je;
    }
    function ht(e, i, s) {
      return Ie(e, false);
    }
    function pt(e) {
      var i = e.prototype;
      return !!(i && i.isReactComponent);
    }
    function ae(e, i, s) {
      if (e == null)
        return "";
      if (typeof e == "function")
        return Ie(e, pt(e));
      if (typeof e == "string")
        return ie(e);
      switch (e) {
        case y:
          return ie("Suspense");
        case h:
          return ie("SuspenseList");
      }
      if (typeof e == "object")
        switch (e.$$typeof) {
          case b:
            return ht(e.render);
          case x:
            return ae(e.type, i, s);
          case T: {
            var u = e, p = u._payload, m = u._init;
            try {
              return ae(m(p), i, s);
            } catch {
            }
          }
        }
      return "";
    }
    var se = Object.prototype.hasOwnProperty, ze = {}, Ge = G.ReactDebugCurrentFrame;
    function ue(e) {
      if (e) {
        var i = e._owner, s = ae(e.type, e._source, i ? i.type : null);
        Ge.setExtraStackFrame(s);
      } else
        Ge.setExtraStackFrame(null);
    }
    function bt(e, i, s, u, p) {
      {
        var m = Function.call.bind(se);
        for (var v in e)
          if (m(e, v)) {
            var d = void 0;
            try {
              if (typeof e[v] != "function") {
                var S = Error((u || "React class") + ": " + s + " type `" + v + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof e[v] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw S.name = "Invariant Violation", S;
              }
              d = e[v](i, v, u, s, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (E) {
              d = E;
            }
            d && !(d instanceof Error) && (ue(p), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", u || "React class", s, v, typeof d), ue(null)), d instanceof Error && !(d.message in ze) && (ze[d.message] = true, ue(p), w("Failed %s type: %s", s, d.message), ue(null));
          }
      }
    }
    var gt = Array.isArray;
    function ye(e) {
      return gt(e);
    }
    function mt(e) {
      {
        var i = typeof Symbol == "function" && Symbol.toStringTag, s = i && e[Symbol.toStringTag] || e.constructor.name || "Object";
        return s;
      }
    }
    function _t(e) {
      try {
        return Le(e), false;
      } catch {
        return true;
      }
    }
    function Le(e) {
      return "" + e;
    }
    function We(e) {
      if (_t(e))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", mt(e)), Le(e);
    }
    var Z = G.ReactCurrentOwner, yt = {
      key: true,
      ref: true,
      __self: true,
      __source: true
    }, $e, Ye, Ee;
    Ee = {};
    function Et(e) {
      if (se.call(e, "ref")) {
        var i = Object.getOwnPropertyDescriptor(e, "ref").get;
        if (i && i.isReactWarning)
          return false;
      }
      return e.ref !== void 0;
    }
    function Rt(e) {
      if (se.call(e, "key")) {
        var i = Object.getOwnPropertyDescriptor(e, "key").get;
        if (i && i.isReactWarning)
          return false;
      }
      return e.key !== void 0;
    }
    function wt(e, i) {
      if (typeof e.ref == "string" && Z.current && i && Z.current.stateNode !== i) {
        var s = _(Z.current.type);
        Ee[s] || (w('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', _(Z.current.type), e.ref), Ee[s] = true);
      }
    }
    function Ot(e, i) {
      {
        var s = function() {
          $e || ($e = true, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", i));
        };
        s.isReactWarning = true, Object.defineProperty(e, "key", {
          get: s,
          configurable: true
        });
      }
    }
    function xt(e, i) {
      {
        var s = function() {
          Ye || (Ye = true, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", i));
        };
        s.isReactWarning = true, Object.defineProperty(e, "ref", {
          get: s,
          configurable: true
        });
      }
    }
    var Ct = function(e, i, s, u, p, m, v) {
      var d = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: e,
        key: i,
        ref: s,
        props: v,
        // Record the component responsible for creating this element.
        _owner: m
      };
      return d._store = {}, Object.defineProperty(d._store, "validated", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: false
      }), Object.defineProperty(d, "_self", {
        configurable: false,
        enumerable: false,
        writable: false,
        value: u
      }), Object.defineProperty(d, "_source", {
        configurable: false,
        enumerable: false,
        writable: false,
        value: p
      }), Object.freeze && (Object.freeze(d.props), Object.freeze(d)), d;
    };
    function Tt(e, i, s, u, p) {
      {
        var m, v = {}, d = null, S = null;
        s !== void 0 && (We(s), d = "" + s), Rt(i) && (We(i.key), d = "" + i.key), Et(i) && (S = i.ref, wt(i, p));
        for (m in i)
          se.call(i, m) && !yt.hasOwnProperty(m) && (v[m] = i[m]);
        if (e && e.defaultProps) {
          var E = e.defaultProps;
          for (m in E)
            v[m] === void 0 && (v[m] = E[m]);
        }
        if (d || S) {
          var R = typeof e == "function" ? e.displayName || e.name || "Unknown" : e;
          d && Ot(v, R), S && xt(v, R);
        }
        return Ct(e, d, S, p, u, Z.current, v);
      }
    }
    var Re = G.ReactCurrentOwner, Ne = G.ReactDebugCurrentFrame;
    function V(e) {
      if (e) {
        var i = e._owner, s = ae(e.type, e._source, i ? i.type : null);
        Ne.setExtraStackFrame(s);
      } else
        Ne.setExtraStackFrame(null);
    }
    var we;
    we = false;
    function Oe(e) {
      return typeof e == "object" && e !== null && e.$$typeof === t;
    }
    function Ve() {
      {
        if (Re.current) {
          var e = _(Re.current.type);
          if (e)
            return `

Check the render method of \`` + e + "`.";
        }
        return "";
      }
    }
    function Pt(e) {
      {
        if (e !== void 0) {
          var i = e.fileName.replace(/^.*[\\\/]/, ""), s = e.lineNumber;
          return `

Check your code at ` + i + ":" + s + ".";
        }
        return "";
      }
    }
    var Ue = {};
    function St(e) {
      {
        var i = Ve();
        if (!i) {
          var s = typeof e == "string" ? e : e.displayName || e.name;
          s && (i = `

Check the top-level render call using <` + s + ">.");
        }
        return i;
      }
    }
    function Be(e, i) {
      {
        if (!e._store || e._store.validated || e.key != null)
          return;
        e._store.validated = true;
        var s = St(i);
        if (Ue[s])
          return;
        Ue[s] = true;
        var u = "";
        e && e._owner && e._owner !== Re.current && (u = " It was passed a child from " + _(e._owner.type) + "."), V(e), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', s, u), V(null);
      }
    }
    function He(e, i) {
      {
        if (typeof e != "object")
          return;
        if (ye(e))
          for (var s = 0; s < e.length; s++) {
            var u = e[s];
            Oe(u) && Be(u, i);
          }
        else if (Oe(e))
          e._store && (e._store.validated = true);
        else if (e) {
          var p = P(e);
          if (typeof p == "function" && p !== e.entries)
            for (var m = p.call(e), v; !(v = m.next()).done; )
              Oe(v.value) && Be(v.value, i);
        }
      }
    }
    function Mt(e) {
      {
        var i = e.type;
        if (i == null || typeof i == "string")
          return;
        var s;
        if (typeof i == "function")
          s = i.propTypes;
        else if (typeof i == "object" && (i.$$typeof === b || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        i.$$typeof === x))
          s = i.propTypes;
        else
          return;
        if (s) {
          var u = _(i);
          bt(s, e.props, "prop", u, e);
        } else if (i.PropTypes !== void 0 && !we) {
          we = true;
          var p = _(i);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", p || "Unknown");
        }
        typeof i.getDefaultProps == "function" && !i.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function jt(e) {
      {
        for (var i = Object.keys(e.props), s = 0; s < i.length; s++) {
          var u = i[s];
          if (u !== "children" && u !== "key") {
            V(e), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", u), V(null);
            break;
          }
        }
        e.ref !== null && (V(e), w("Invalid attribute `ref` supplied to `React.Fragment`."), V(null));
      }
    }
    function qe(e, i, s, u, p, m) {
      {
        var v = O(e);
        if (!v) {
          var d = "";
          (e === void 0 || typeof e == "object" && e !== null && Object.keys(e).length === 0) && (d += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var S = Pt(p);
          S ? d += S : d += Ve();
          var E;
          e === null ? E = "null" : ye(e) ? E = "array" : e !== void 0 && e.$$typeof === t ? (E = "<" + (_(e.type) || "Unknown") + " />", d = " Did you accidentally export a JSX literal instead of a component?") : E = typeof e, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", E, d);
        }
        var R = Tt(e, i, s, p, m);
        if (R == null)
          return R;
        if (v) {
          var k = i.children;
          if (k !== void 0)
            if (u)
              if (ye(k)) {
                for (var U = 0; U < k.length; U++)
                  He(k[U], e);
                Object.freeze && Object.freeze(k);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              He(k, e);
        }
        return e === o ? jt(R) : Mt(R), R;
      }
    }
    function kt(e, i, s) {
      return qe(e, i, s, true);
    }
    function At(e, i, s) {
      return qe(e, i, s, false);
    }
    var Dt = At, Ft = kt;
    Q.Fragment = o, Q.jsx = Dt, Q.jsxs = Ft;
  }()), Q;
}
false ? Ce.exports = Gt() : Ce.exports = Lt();
var L = Ce.exports;
var it = function() {
  if (typeof Map < "u")
    return Map;
  function r(t, n) {
    var o = -1;
    return t.some(function(a, c) {
      return a[0] === n ? (o = c, true) : false;
    }), o;
  }
  return (
    /** @class */
    function() {
      function t() {
        this.__entries__ = [];
      }
      return Object.defineProperty(t.prototype, "size", {
        /**
         * @returns {boolean}
         */
        get: function() {
          return this.__entries__.length;
        },
        enumerable: true,
        configurable: true
      }), t.prototype.get = function(n) {
        var o = r(this.__entries__, n), a = this.__entries__[o];
        return a && a[1];
      }, t.prototype.set = function(n, o) {
        var a = r(this.__entries__, n);
        ~a ? this.__entries__[a][1] = o : this.__entries__.push([n, o]);
      }, t.prototype.delete = function(n) {
        var o = this.__entries__, a = r(o, n);
        ~a && o.splice(a, 1);
      }, t.prototype.has = function(n) {
        return !!~r(this.__entries__, n);
      }, t.prototype.clear = function() {
        this.__entries__.splice(0);
      }, t.prototype.forEach = function(n, o) {
        o === void 0 && (o = null);
        for (var a = 0, c = this.__entries__; a < c.length; a++) {
          var g = c[a];
          n.call(o, g[1], g[0]);
        }
      }, t;
    }()
  );
}();
var Te = typeof window < "u" && typeof document < "u" && window.document === document;
var ce = function() {
  return typeof global < "u" && global.Math === Math ? global : typeof self < "u" && self.Math === Math ? self : typeof window < "u" && window.Math === Math ? window : Function("return this")();
}();
var Wt = function() {
  return typeof requestAnimationFrame == "function" ? requestAnimationFrame.bind(ce) : function(r) {
    return setTimeout(function() {
      return r(Date.now());
    }, 1e3 / 60);
  };
}();
var $t = 2;
function Yt(r, t) {
  var n = false, o = false, a = 0;
  function c() {
    n && (n = false, r()), o && f();
  }
  function g() {
    Wt(c);
  }
  function f() {
    var b = Date.now();
    if (n) {
      if (b - a < $t)
        return;
      o = true;
    } else
      n = true, o = false, setTimeout(g, t);
    a = b;
  }
  return f;
}
var Nt = 20;
var Vt = ["top", "right", "bottom", "left", "width", "height", "size", "weight"];
var Ut = typeof MutationObserver < "u";
var Bt = (
  /** @class */
  function() {
    function r() {
      this.connected_ = false, this.mutationEventsAdded_ = false, this.mutationsObserver_ = null, this.observers_ = [], this.onTransitionEnd_ = this.onTransitionEnd_.bind(this), this.refresh = Yt(this.refresh.bind(this), Nt);
    }
    return r.prototype.addObserver = function(t) {
      ~this.observers_.indexOf(t) || this.observers_.push(t), this.connected_ || this.connect_();
    }, r.prototype.removeObserver = function(t) {
      var n = this.observers_, o = n.indexOf(t);
      ~o && n.splice(o, 1), !n.length && this.connected_ && this.disconnect_();
    }, r.prototype.refresh = function() {
      var t = this.updateObservers_();
      t && this.refresh();
    }, r.prototype.updateObservers_ = function() {
      var t = this.observers_.filter(function(n) {
        return n.gatherActive(), n.hasActive();
      });
      return t.forEach(function(n) {
        return n.broadcastActive();
      }), t.length > 0;
    }, r.prototype.connect_ = function() {
      !Te || this.connected_ || (document.addEventListener("transitionend", this.onTransitionEnd_), window.addEventListener("resize", this.refresh), Ut ? (this.mutationsObserver_ = new MutationObserver(this.refresh), this.mutationsObserver_.observe(document, {
        attributes: true,
        childList: true,
        characterData: true,
        subtree: true
      })) : (document.addEventListener("DOMSubtreeModified", this.refresh), this.mutationEventsAdded_ = true), this.connected_ = true);
    }, r.prototype.disconnect_ = function() {
      !Te || !this.connected_ || (document.removeEventListener("transitionend", this.onTransitionEnd_), window.removeEventListener("resize", this.refresh), this.mutationsObserver_ && this.mutationsObserver_.disconnect(), this.mutationEventsAdded_ && document.removeEventListener("DOMSubtreeModified", this.refresh), this.mutationsObserver_ = null, this.mutationEventsAdded_ = false, this.connected_ = false);
    }, r.prototype.onTransitionEnd_ = function(t) {
      var n = t.propertyName, o = n === void 0 ? "" : n, a = Vt.some(function(c) {
        return !!~o.indexOf(c);
      });
      a && this.refresh();
    }, r.getInstance = function() {
      return this.instance_ || (this.instance_ = new r()), this.instance_;
    }, r.instance_ = null, r;
  }()
);
var ot = function(r, t) {
  for (var n = 0, o = Object.keys(t); n < o.length; n++) {
    var a = o[n];
    Object.defineProperty(r, a, {
      value: t[a],
      enumerable: false,
      writable: false,
      configurable: true
    });
  }
  return r;
};
var J = function(r) {
  var t = r && r.ownerDocument && r.ownerDocument.defaultView;
  return t || ce;
};
var at = de(0, 0, 0, 0);
function le(r) {
  return parseFloat(r) || 0;
}
function Qe(r) {
  for (var t = [], n = 1; n < arguments.length; n++)
    t[n - 1] = arguments[n];
  return t.reduce(function(o, a) {
    var c = r["border-" + a + "-width"];
    return o + le(c);
  }, 0);
}
function Ht(r) {
  for (var t = ["top", "right", "bottom", "left"], n = {}, o = 0, a = t; o < a.length; o++) {
    var c = a[o], g = r["padding-" + c];
    n[c] = le(g);
  }
  return n;
}
function qt(r) {
  var t = r.getBBox();
  return de(0, 0, t.width, t.height);
}
function Jt(r) {
  var t = r.clientWidth, n = r.clientHeight;
  if (!t && !n)
    return at;
  var o = J(r).getComputedStyle(r), a = Ht(o), c = a.left + a.right, g = a.top + a.bottom, f = le(o.width), b = le(o.height);
  if (o.boxSizing === "border-box" && (Math.round(f + c) !== t && (f -= Qe(o, "left", "right") + c), Math.round(b + g) !== n && (b -= Qe(o, "top", "bottom") + g)), !Zt(r)) {
    var y = Math.round(f + c) - t, h = Math.round(b + g) - n;
    Math.abs(y) !== 1 && (f -= y), Math.abs(h) !== 1 && (b -= h);
  }
  return de(a.left, a.top, f, b);
}
var Kt = /* @__PURE__ */ function() {
  return typeof SVGGraphicsElement < "u" ? function(r) {
    return r instanceof J(r).SVGGraphicsElement;
  } : function(r) {
    return r instanceof J(r).SVGElement && typeof r.getBBox == "function";
  };
}();
function Zt(r) {
  return r === J(r).document.documentElement;
}
function Xt(r) {
  return Te ? Kt(r) ? qt(r) : Jt(r) : at;
}
function Qt(r) {
  var t = r.x, n = r.y, o = r.width, a = r.height, c = typeof DOMRectReadOnly < "u" ? DOMRectReadOnly : Object, g = Object.create(c.prototype);
  return ot(g, {
    x: t,
    y: n,
    width: o,
    height: a,
    top: n,
    right: t + o,
    bottom: a + n,
    left: t
  }), g;
}
function de(r, t, n, o) {
  return { x: r, y: t, width: n, height: o };
}
var er = (
  /** @class */
  function() {
    function r(t) {
      this.broadcastWidth = 0, this.broadcastHeight = 0, this.contentRect_ = de(0, 0, 0, 0), this.target = t;
    }
    return r.prototype.isActive = function() {
      var t = Xt(this.target);
      return this.contentRect_ = t, t.width !== this.broadcastWidth || t.height !== this.broadcastHeight;
    }, r.prototype.broadcastRect = function() {
      var t = this.contentRect_;
      return this.broadcastWidth = t.width, this.broadcastHeight = t.height, t;
    }, r;
  }()
);
var tr = (
  /** @class */
  /* @__PURE__ */ function() {
    function r(t, n) {
      var o = Qt(n);
      ot(this, { target: t, contentRect: o });
    }
    return r;
  }()
);
var rr = (
  /** @class */
  function() {
    function r(t, n, o) {
      if (this.activeObservations_ = [], this.observations_ = new it(), typeof t != "function")
        throw new TypeError("The callback provided as parameter 1 is not a function.");
      this.callback_ = t, this.controller_ = n, this.callbackCtx_ = o;
    }
    return r.prototype.observe = function(t) {
      if (!arguments.length)
        throw new TypeError("1 argument required, but only 0 present.");
      if (!(typeof Element > "u" || !(Element instanceof Object))) {
        if (!(t instanceof J(t).Element))
          throw new TypeError('parameter 1 is not of type "Element".');
        var n = this.observations_;
        n.has(t) || (n.set(t, new er(t)), this.controller_.addObserver(this), this.controller_.refresh());
      }
    }, r.prototype.unobserve = function(t) {
      if (!arguments.length)
        throw new TypeError("1 argument required, but only 0 present.");
      if (!(typeof Element > "u" || !(Element instanceof Object))) {
        if (!(t instanceof J(t).Element))
          throw new TypeError('parameter 1 is not of type "Element".');
        var n = this.observations_;
        n.has(t) && (n.delete(t), n.size || this.controller_.removeObserver(this));
      }
    }, r.prototype.disconnect = function() {
      this.clearActive(), this.observations_.clear(), this.controller_.removeObserver(this);
    }, r.prototype.gatherActive = function() {
      var t = this;
      this.clearActive(), this.observations_.forEach(function(n) {
        n.isActive() && t.activeObservations_.push(n);
      });
    }, r.prototype.broadcastActive = function() {
      if (this.hasActive()) {
        var t = this.callbackCtx_, n = this.activeObservations_.map(function(o) {
          return new tr(o.target, o.broadcastRect());
        });
        this.callback_.call(t, n, t), this.clearActive();
      }
    }, r.prototype.clearActive = function() {
      this.activeObservations_.splice(0);
    }, r.prototype.hasActive = function() {
      return this.activeObservations_.length > 0;
    }, r;
  }()
);
var st = typeof WeakMap < "u" ? /* @__PURE__ */ new WeakMap() : new it();
var ut = (
  /** @class */
  /* @__PURE__ */ function() {
    function r(t) {
      if (!(this instanceof r))
        throw new TypeError("Cannot call a class as a function.");
      if (!arguments.length)
        throw new TypeError("1 argument required, but only 0 present.");
      var n = Bt.getInstance(), o = new rr(t, n, this);
      st.set(this, o);
    }
    return r;
  }()
);
[
  "observe",
  "unobserve",
  "disconnect"
].forEach(function(r) {
  ut.prototype[r] = function() {
    var t;
    return (t = st.get(this))[r].apply(t, arguments);
  };
});
var nr = function() {
  return typeof ce.ResizeObserver < "u" ? ce.ResizeObserver : ut;
}();
function fe(r, t) {
  import_zdog.default.extend(r, t);
}
var A = (r) => import_react.default.forwardRef(({ children: t, ...n }, o) => lt(r, t, n, o)[0]);
function ct() {
  const t = Math.floor(Math.random() * 16777216).toString(16).toUpperCase();
  return "#" + t.padStart(6, "0") === "#000000" ? ct() : "#" + t.padStart(6, "0");
}
var xe = (r) => {
  let t = r.toString(16);
  return t.length == 1 ? "0" + t : t;
};
var ir = (r, t, n) => "#" + xe(r) + xe(t) + xe(n);
function Pe(r, t, n) {
  return new Proxy(r, {
    set(o, a, c) {
      return typeof c == "object" && c !== null && (c = Pe(c, t)), t(o, a, c, n), o[a] = c, true;
    },
    get(o, a) {
      return typeof o[a] == "object" && o[a] !== null ? Pe(o[a], t, a) : o[a];
    }
  });
}
var et = (r, t, n) => {
  const o = r.getBoundingClientRect();
  return {
    x: (t.clientX - o.left) / (o.right - o.left) * n.width,
    y: (t.clientY - o.top) / (o.bottom - o.top) * n.height
  };
};
var tt = ({ x: r, y: t, canvasContext: n }) => {
  let a = n.getImageData(r, t, 1, 1).data;
  return ir(a[0], a[1], a[2]);
};
var ve = import_react.default.createContext();
var rt = import_react.default.createContext();
var nt = import_react.default.createContext();
function or() {
  const r = (0, import_react.useRef)(), [t, n] = (0, import_react.useState)({ left: 0, top: 0, width: 0, height: 0 }), [o] = (0, import_react.useState)(() => new nr(([a]) => n(a.contentRect)));
  return (0, import_react.useEffect)(() => (r.current && o.observe(r.current), () => o.disconnect()), [r.current]), [{ ref: r }, t];
}
function cr(r, t = []) {
  const n = (0, import_react.useContext)(ve);
  (0, import_react.useEffect)(() => {
    const o = n.current.subscribe(r);
    return () => o();
  }, t);
}
function ar() {
  return (0, import_react.useContext)(ve).current;
}
function lt(r, t, n, o) {
  const a = (0, import_react.useContext)(ve), c = (0, import_react.useContext)(rt), g = (0, import_react.useContext)(nt), f = (0, import_react.useMemo)(() => ct(), []), b = (0, import_react.useMemo)(() => ({
    stroke: false,
    ...n,
    color: f,
    leftFace: f,
    rightFace: f,
    topFace: f,
    bottomFace: f
  }), [f, n]), [y] = (0, import_react.useState)(() => new r(n)), [h] = (0, import_react.useState)(() => new r(b)), x = (z, W, N, P) => {
    P ? h[P][W] = N : h[W] = N, a.current.illu.updateRenderGraph();
  }, [T] = (0, import_react.useState)(() => Pe(y, x));
  return (0, import_react.useImperativeHandle)(o, () => T), (0, import_react.useLayoutEffect)(() => {
    fe(y, n), c && a.current.illu.updateRenderGraph();
  }, [n]), (0, import_react.useLayoutEffect)(() => {
    fe(h, b);
  }, [b]), (0, import_react.useLayoutEffect)(() => {
    if (c)
      return c.addChild(y), a.current.illu.updateGraph(), () => {
        c.removeChild(y), c.updateFlatGraph(), a.current.illu.updateGraph();
      };
  }, [c]), (0, import_react.useEffect)(() => {
    if (c)
      return a.current.itemMap[f] = y, n.onClick && (a.current.clickEventMap[f] = n.onClick), n.onPointerMove && (a.current.pointerMoveEventMap[f] = n.onPointerMove), n.onPointerEnter && (a.current.pointerEnterEventMap[f] = n.onPointerEnter), n.onPointerLeave && (a.current.pointerLeaveEventMap[f] = n.onPointerLeave), () => {
        delete a.current.itemMap[f], delete a.current.clickEventMap[f], delete a.current.pointerMoveEventMap[f], delete a.current.pointerEnterEventMap[f], delete a.current.pointerLeaveEventMap[f];
      };
  }, [n]), (0, import_react.useLayoutEffect)(() => {
    if (g)
      return g.addChild(h), a.current.illu_ghost.updateGraph(), () => {
        g.removeChild(h), g.updateFlatGraph(), a.current.illu_ghost.updateGraph();
      };
  }, [g]), [
    L.jsx(nt.Provider, { value: h, children: L.jsx(rt.Provider, { value: y, children: t }) }, f),
    y,
    h
  ];
}
function lr() {
  const r = ar();
  return (0, import_react.useCallback)(() => r.illu.updateRenderGraph(), [r]);
}
var fr = import_react.default.memo(
  ({
    children: r,
    style: t,
    resize: n,
    element: o = "svg",
    frameloop: a = "always",
    dragRotate: c,
    onDragMove: g = () => {
    },
    onDragStart: f = () => {
    },
    onDragEnd: b = () => {
    },
    pointerEvents: y = false,
    ...h
  }) => {
    const x = (0, import_react.useRef)(), T = (0, import_react.useRef)(), [z, W] = (0, import_react.useState)(null);
    (0, import_react.useEffect)(() => {
      W(T.current.getContext("2d", { willReadFrequently: true }));
    }, []);
    const [N, P] = or(), [G, w, he] = lt(import_zdog.default.Anchor, r), l = (0, import_react.useRef)({
      scene: w,
      illu: void 0,
      size: {},
      subscribers: [],
      subscribe: (O) => (l.current.subscribers.push(O), () => l.current.subscribers = l.current.subscribers.filter((F) => F !== O)),
      illu_ghost: void 0,
      itemMap: {},
      clickEventMap: {},
      pointerMoveEventMap: {},
      pointerEnterEventMap: {},
      pointerLeaveEventMap: {},
      pointerEvents: y
    });
    (0, import_react.useEffect)(() => {
      l.current.size = P, l.current.illu && (l.current.illu.setSize(P.width, P.height), l.current.illu_ghost.setSize(P.width, P.height), a === "demand" && (l.current.illu.updateRenderGraph(), l.current.illu_ghost.updateRenderGraph()));
    }, [P]), (0, import_react.useEffect)(() => {
      l.current.illu = new import_zdog.default.Illustration({
        element: x.current,
        dragRotate: c,
        onDragMove: () => {
          l.current.illu_ghost.rotate = {
            x: l.current.illu.rotate.x,
            y: l.current.illu.rotate.y,
            z: l.current.illu.rotate.z
          }, g();
        },
        onDragStart: f,
        onDragEnd: b,
        ...h
      }), l.current.illu.addChild(w), l.current.illu.updateGraph(), l.current.illu_ghost = new import_zdog.default.Illustration({
        element: T.current,
        ...h
      }), l.current.illu_ghost.addChild(he), l.current.illu_ghost.updateGraph();
      let O, F = true;
      function $(_) {
        const { size: C, subscribers: j } = l.current;
        C.width && C.height && (j.forEach((ne) => ne(_)), a !== "demand" && l.current.illu.updateRenderGraph()), F && a !== "demand" && (O = requestAnimationFrame($));
      }
      return $(), () => {
        F = false, cancelAnimationFrame(O);
      };
    }, [a]), (0, import_react.useLayoutEffect)(() => {
      l.current.illu && fe(l.current.illu, h), l.current.illu_ghost && fe(l.current.illu_ghost, h);
    }, [h]);
    const pe = (O) => {
      if (!y)
        return;
      l.current.illu_ghost && l.current.illu_ghost.updateRenderGraph();
      const F = et(x.current, O, T.current), _ = tt({ ...F, canvasContext: z }).toUpperCase(), C = l.current.clickEventMap[_];
      C && C(O, l.current.itemMap[_]);
    }, D = (0, import_react.useRef)(null), K = (0, import_react.useRef)(null), be = (O) => {
      K.current = O;
    }, re = (O) => {
      if (!y)
        return;
      l.current.illu_ghost && l.current.illu_ghost.updateRenderGraph();
      const F = et(x.current, O, T.current), _ = tt({ ...F, canvasContext: z }).toUpperCase();
      if (_ !== "#000000" && D.current !== _ && K.current !== _) {
        const j = l.current.pointerEnterEventMap[_];
        j && j(O, l.current.itemMap[_]), be(D.current);
      }
      if (D.current && D.current !== "#000000" && D.current !== _ && K.current) {
        const j = l.current.pointerLeaveEventMap[D.current];
        j && j(O, l.current.itemMap[D.current]);
      }
      const C = l.current.pointerMoveEventMap[_];
      C && C(O, l.current.itemMap[_]), D.current = _;
    };
    return L.jsxs(L.Fragment, { children: [
      L.jsxs(
        "div",
        {
          ref: N.ref,
          ...h,
          style: {
            position: "relative",
            width: "100%",
            height: "100%",
            overflow: "hidden",
            boxSizing: "border-box",
            ...t
          },
          children: [
            L.jsx(
              o,
              {
                ref: x,
                style: { display: "block", boxSizing: "border-box" },
                width: P.width,
                height: P.height,
                onClick: pe,
                onPointerMove: re
              }
            ),
            l.current.illu && L.jsx(ve.Provider, { value: l, children: G })
          ]
        }
      ),
      L.jsx(
        "canvas",
        {
          ref: T,
          style: {
            display: "block",
            boxSizing: "border-box",
            opacity: "0",
            position: "fixed",
            zIndex: "1000",
            pointerEvents: "none",
            background: "black"
          },
          width: P.width,
          height: P.height
        }
      )
    ] });
  }
);
var dr = A(import_zdog.default.Anchor);
var vr = A(import_zdog.default.Shape);
var hr = A(import_zdog.default.Group);
var pr = A(import_zdog.default.Rect);
var br = A(import_zdog.default.RoundedRect);
var gr = A(import_zdog.default.Ellipse);
var mr = A(import_zdog.default.Polygon);
var _r = A(import_zdog.default.Hemisphere);
var yr = A(import_zdog.default.Cylinder);
var Er = A(import_zdog.default.Cone);
var Rr = A(import_zdog.default.Box);
export {
  dr as Anchor,
  Rr as Box,
  Er as Cone,
  yr as Cylinder,
  gr as Ellipse,
  hr as Group,
  _r as Hemisphere,
  fr as Illustration,
  mr as Polygon,
  pr as Rect,
  br as RoundedRect,
  vr as Shape,
  lr as useInvalidate,
  cr as useRender,
  ar as useZdog
};
/*! Bundled license information:

zdog/js/boilerplate.js:
  (*!
   * Zdog v1.1.3
   * Round, flat, designer-friendly pseudo-3D engine
   * Licensed MIT
   * https://zzz.dog
   * Copyright 2020 Metafizzy
   *)

react-zdog/dist/react-zdog.es.js:
  (**
   * @license React
   * react-jsx-runtime.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-zdog/dist/react-zdog.es.js:
  (**
   * @license React
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=react-zdog.js.map
